<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Clojure Dojo and PubSub</title>
    <meta name="viewport" content="width=device-width">

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

    <!-- Responsive CSS -->
    <link rel="stylesheet" href="/css/responsive.css">

    <!-- Google Fonts -->
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Raleway:300,400,700' rel='stylesheet' type='text/css'>

    <!-- Link to RSS feed -->
    
      <link rel="home" type="application/atom+xml" href="/feed.xml">
    

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-51485241-1', 'nbeloglazov.com');
      ga('send', 'pageview');
    </script>
    <script type="text/javascript" src="https://apis.google.com/js/plusone.js" async="true"></script>
  </head>
  <body>
    <div class="site">
      <aside class="sidebar" id="sidebar">
        <div class="header">
          
            <h1 class="title"><a href="/"><img id="avatar" src="/images/avatar.jpg"></a></h1>
            <span class="tagline">
              Quil, Ð¡lojure and programming in general
            </span>
          
        </div>
        <div class="posts">
          <ul class="posts-list">
            
              <li class="post-link">
                <a class="post-title" href="/2015/06/15/live-reloading-in-quil-cljs.html">
                  <span class="post-date">15 Jun 2015</span>
                  Live Reloading in Quil Cljs
                </a>
              </li>
            
              <li class="post-link">
                <a class="post-title" href="/2015/05/18/trees-quil-and-random.html">
                  <span class="post-date">18 May 2015</span>
                  Trees, Quil and Random
                </a>
              </li>
            
              <li class="post-link">
                <a class="post-title" href="/2014/12/15/backup-mongodb-using-clojure.html">
                  <span class="post-date">15 Dec 2014</span>
                  Mongo Backup Using Clojure
                </a>
              </li>
            
              <li class="post-link">
                <a class="post-title" href="/2014/11/24/github-actions-in-hatnik.html">
                  <span class="post-date">24 Nov 2014</span>
                  GitHub Actions in Hatnik
                </a>
              </li>
            
          </ul>
       </div>
       <p class="all-posts-link">
         
         <a href="/all.html">All posts</a>
         
        </p>
        <div class="footer">
          <span id="footer-links">
            <a href="https://github.com/nbeloglazov" class="footer-link">GitHub</a>
            <span class="separator">&bull;</span>
            <a href="https://www.linkedin.com/in/nikitabeloglazov/" class="footer-link">LinkedIn</a>
            <span class="separator">&bull;</span>
            <a href="https://twitter.com/BeloglazovN/" class="footer-link">Twitter</a>
            <span class="separator">&bull;</span>
            
            <a href="/feed.xml">
            
              <img class="rss" src="/images/rss.png"/>
            </a>
          </span>
        </div>
      </aside>
        <article class="content" id="home">
  <div id="fb-root"></div>
  <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=258381704207913&version=v2.0";
    fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>
  <div id="sidebar-button">
    <img src="/images/sidebar-button.png">
  </div>
  <div id="post-info">
    <div id="info-container">
      
      
        <a href="/ru/2014/07/15/clojure-dojo-and-pubsub.html" class="lang-link">Ru</a>
        <p class="lang-link">En</p>
      
      
      <h1 id="title">Clojure Dojo and PubSub</h1>
      <time datetime="2014-07-15" id="date" pubdate>15 Jul 2014</time>
    </div>
  </div>

  <div class="post">
    <h3>Clojure Dojo</h3>

<p>This Monday I went to a London Clojure Dojo at uSwitch. Dojos are organized beweekly by some companies like ThoughtWorks or uSwitch. Around 10-15 people gather together, order pizza, propose ideas for coding and then split into teams of 3-5 people to code for ~2 hours. After coding part each team gives 5-minutes presentation of what they have done. Main rule (beside &quot;Have fun&quot;) is that each participant must write at least a couple of lines in Clojure during dojo.</p>

<p>People coming to dojos have quite different clojure background. Some have been coding clojure for years and use it at work. Some have started learning clojure last week and have written only basic &quot;Hello, world&quot;. Ideas for coding are not very complex, after all you have only 2 hours to code and some people don&#39;t have much experience with clojure. For example at the last dojo we got 5 teams. Two of them were teams of beginners, who worked on exercises from <a href="http://exercism.io/">exercism.io</a>. Two teams tried out <a href="https://groups.google.com/forum/#!topic/clojure/6vDnBWOgHDc">Quil on ClojureScript</a>. And finally last team (I was in that team) worked on simple network-level PubSub library.</p>

<p>One of the important issues during the dojo is working environment. A team usually works on a single laptop, because sharing code between several laptops realtime is not an easy task to do. So someone is coding while others discuss and help her/him. One lesson I learned after going to dojos is that editor should be simplest possible. Of course everyone has his/her own favorite setup of emacs/vim/whatever and wants to use it, but it&#39;s a bad idea. I&#39;ve been on some dojos where we were mostly fighting with emacs instead of writing clojure, it was frustrating. Even more, imagine you&#39;re a beginner and you came to a dojo, and now you have to write in language you barely know and use some weird editor which doesn&#39;t behave as normal editors do, double frustrating. So editor should be simple. I think <a href="http://www.lighttable.com/">LightTable</a> is the best clojure editor for dojos. It is easy to start, you can write text without twisting your fingers and brain, and finally, it is very easy to execute clojure code, just &quot;Ctrl+Enter&quot;.</p>

<p>Now I&#39;d like to describe the project my team worked on at the last dojo: PusSub.</p>

<h3>PubSub</h3>

<p>Idea quite simple: write a library which consists of 2 functions: <code>publish</code> and <code>subscribe</code>. It should satisfy following contract:</p>

<ul>
<li>Publishing and subscription are on network level, so each machine gets messages published by other machines on the same network.</li>
<li><code>publish</code> takes 1 argument - message. Message is an arbitrary clojure object (string, map, vector, etc.)</li>
<li><code>subscribe</code> takes 1 argument - handler function which processes messages.</li>
</ul>

<p>As you can see the library should not have concept of addresses, queues or topics. The library should not have concept of a server: clients should be able to communicate to each other without connecting to some kind of server.</p>

<p>For implementation we decided to use <a href="http://en.wikipedia.org/wiki/IP_multicast">IP multicast</a>. We didn&#39;t dig deep into specification and technical details, just googled how to do it in java. We found <code>java.net.MulticastSocket</code> class which does exactly what we want. Even more, <a href="http://docs.oracle.com/javase/7/docs/api/java/net/MulticastSocket.html">javadoc</a> for that class contains nice example of how to use it. We translated it into clojure and enhanced a little bit. Here what we got:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">pubsub.core</span>
  <span class="p">(</span><span class="ss">:import</span> <span class="p">[</span><span class="nv">java.net</span> <span class="nv">InetAddress</span> <span class="nv">DatagramPacket</span> <span class="nv">MulticastSocket</span><span class="p">]))</span>


<span class="c1">; constants specifying multicast address</span>
<span class="p">(</span><span class="k">def </span><span class="nv">address</span> <span class="s">&quot;228.5.6.7&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">port</span> <span class="mi">6789</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">group</span> <span class="p">(</span><span class="nf">InetAddress/getByName</span> <span class="nv">address</span><span class="p">))</span>


<span class="c1">; function to create new multicast socket</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">init-comm</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nf">MulticastSocket.</span> <span class="nv">port</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">.joinGroup</span> <span class="nv">s</span> <span class="nv">group</span><span class="p">)</span>
    <span class="nv">s</span><span class="p">))</span>

<span class="c1">; define socket to be used for sending message from current machine</span>
<span class="p">(</span><span class="k">def </span><span class="nv">socket</span> <span class="p">(</span><span class="nf">init-comm</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">get-packet</span> <span class="p">[</span><span class="nv">message</span> <span class="nv">group</span> <span class="nv">port</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">DatagramPacket.</span> <span class="p">(</span><span class="nf">.getBytes</span> <span class="nv">message</span><span class="p">)</span> <span class="p">(</span><span class="nf">.length</span> <span class="nv">message</span><span class="p">)</span> <span class="nv">group</span> <span class="nv">port</span><span class="p">))</span>

<span class="c1">; define &#39;publish&#39; function. For some reason we named it &#39;send-it&#39;</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">send-it</span> <span class="p">[</span><span class="nv">message</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">.send</span> <span class="nv">socket</span> <span class="p">(</span><span class="nf">get-packet</span> <span class="p">(</span><span class="nb">pr-str </span><span class="nv">message</span><span class="p">)</span> <span class="nv">group</span> <span class="nv">port</span><span class="p">)))</span>
</code></pre></div>
<p>Now we can publish messages, cool! As you can see we use <a href="https://github.com/edn-format/edn">EDN</a> as format for sending messages (<code>pr-str</code> converts clojure object to EDN string). Now it is time to implement subscription mechanism. We diverted a little bit from initial goal and implemented more complex subscription model. It has 2 features not mentioned in initial design:</p>

<ul>
<li>Instead of passing only handler function, we pass 2 functions: predicate and handler. Predicate checks whether message should be processed and if it returns true then handler is invoked.</li>
<li>Initial design doesn&#39;t have a mechanism to unsubscribe handler. We added it. When you subscribe, a promise object is created. The promise is used as finished flag: subscription halts once someone delivered anything into the promise. The promise is returned from <code>subscribe</code> function so user can put any value to it to unsubscribe.</li>
</ul>

<p>Here is the code:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="c1">; &#39;process-message&#39; is a recursive function used to process messages</span>
<span class="c1">; Parameters</span>
<span class="c1">;   socket - socket object to receive message from</span>
<span class="c1">;   predicate - user-provided function which decides whether process message or not</span>
<span class="c1">;   handler - user-provided function which processes message</span>
<span class="c1">;   finished - promise which indicates when to unsubscribe</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">process-message</span> <span class="p">[</span><span class="nv">socket</span> <span class="nv">predicate</span> <span class="nv">handler</span> <span class="nv">finished</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">size</span> <span class="mi">1000</span>
        <span class="nv">packet</span> <span class="p">(</span><span class="nf">DatagramPacket.</span> <span class="p">(</span><span class="nf">byte-array</span> <span class="nv">size</span><span class="p">)</span> <span class="nv">size</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">when-not </span><span class="p">(</span><span class="nf">realized?</span> <span class="nv">finished</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.receive</span> <span class="nv">socket</span> <span class="nv">packet</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">packet</span> <span class="nv">.getData</span> <span class="p">(</span><span class="nf">String.</span><span class="p">)</span> <span class="nv">read-string</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">predicate</span> <span class="nv">obj</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">handler</span> <span class="nv">obj</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="nv">socket</span> <span class="nv">predicate</span> <span class="nv">handler</span> <span class="nv">finished</span><span class="p">)))</span>

<span class="c1">; &#39;subscribe&#39; function. Again, we named it differently :)</span>
<span class="c1">; It has 2 versions, first is classic, takes only handler.</span>
<span class="c1">; Second version takes predicate and handler.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">subscribe-with</span>
  <span class="p">([</span><span class="nv">handler</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">subscribe-with</span> <span class="p">(</span><span class="nb">constantly </span><span class="nv">true</span><span class="p">)</span> <span class="nv">handler</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">predicate</span> <span class="nv">handler</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">socket</span> <span class="p">(</span><span class="nf">init-comm</span><span class="p">)</span>
          <span class="nv">finished</span> <span class="p">(</span><span class="nf">promise</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">future</span>
        <span class="p">(</span><span class="nf">process-message</span> <span class="nv">socket</span> <span class="nv">predicate</span> <span class="nv">handler</span> <span class="nv">finished</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">.leaveGroup</span> <span class="nv">socket</span> <span class="nv">group</span><span class="p">))</span>
      <span class="nv">finished</span><span class="p">)))</span>
</code></pre></div>
<p>That&#39;s all. The library is ready to use. Here is how to use it:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">pubsub.core</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">send-it</span> <span class="nv">subscribe-with</span><span class="p">]])</span>

<span class="c1">; subscribe to all messages</span>
<span class="p">(</span><span class="nf">subscribe-with</span> <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Simplest subscribe&quot;</span> <span class="nv">%</span><span class="p">))</span>

<span class="c1">; send message, we should see it printed in console</span>
<span class="p">(</span><span class="nf">send-it</span> <span class="s">&quot;something&quot;</span><span class="p">)</span>

<span class="c1">; subscripe only to messages which are maps and contain topic == :dojo</span>
<span class="p">(</span><span class="nf">subscribe-with</span> <span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="ss">:topic</span> <span class="nv">%</span><span class="p">)</span> <span class="ss">:dojo</span><span class="p">)</span>
                <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Dojo message&quot;</span> <span class="nv">%</span><span class="p">))</span>

<span class="c1">; subscribe only to messages with topic :work</span>
<span class="p">(</span><span class="nf">subscribe-with</span> <span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="ss">:topic</span> <span class="nv">%</span><span class="p">)</span> <span class="ss">:work</span><span class="p">)</span>
                <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Work message&quot;</span> <span class="nv">%</span><span class="p">))</span>

<span class="c1">; subscript only to messages with topic :home</span>
<span class="p">(</span><span class="nf">subscribe-with</span> <span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="ss">:topic</span> <span class="nv">%</span><span class="p">)</span> <span class="ss">:home</span><span class="p">)</span>
                <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Home message&quot;</span> <span class="nv">%</span><span class="p">))</span>

<span class="c1">; send messages with different topics</span>
<span class="p">(</span><span class="nf">send-it</span> <span class="p">{</span><span class="ss">:topic</span> <span class="ss">:dojo</span> <span class="ss">:message</span> <span class="s">&quot;Hello, clojurians!&quot;</span><span class="p">})</span>
<span class="p">(</span><span class="nf">send-it</span> <span class="p">{</span><span class="ss">:topic</span> <span class="ss">:work</span> <span class="ss">:message</span> <span class="s">&quot;You&#39;re at work...&quot;</span><span class="p">})</span>
<span class="p">(</span><span class="nf">send-it</span> <span class="p">{</span><span class="ss">:topic</span> <span class="ss">:home</span> <span class="ss">:message</span> <span class="s">&quot;You&#39;re at home...&quot;</span><span class="p">})</span>
</code></pre></div>
<p>We can built something else on top of the library, for example decentralized chat app or simple multiplayer game. Who knows, it might make a nice project for another dojo.</p>

<p>If you want to play with the code - check project on <a href="https://github.com/nbeloglazov/dojo-pubsub">GitHub</a>.</p>

  </div>
  <div class="colophon">
    <p>
      <span id="pub-date">
        
          Published on
        
        15 Jul 2014
      </span>
    </p>
  </div>
  <div id="social-buttons">
    <g:plusone href="http://nbeloglazov.com/2014/07/15/clojure-dojo-and-pubsub.html"></g:plusone>
    <a href="https://twitter.com/share" class="twitter-share-button" data-text="http://nbeloglazov.com/2014/07/15/clojure-dojo-and-pubsub.html">Tweet</a>
    <script>
      !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
    </script>
    <div class="fb-like" data-href="http://nbeloglazov.com/2014/07/15/clojure-dojo-and-pubsub.html" data-layout="button_count"
         data-action="like" data-show-faces="true" data-share="false"></div>
  </div>
  <!-- AddThis Button END -->
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'nbeloglazovblog';
    var disqus_identifier = '/2014/07/15/clojure-dojo-and-pubsub';
    var disqus_title = 'Clojure Dojo and PubSub';
    var disqus_url = 'http://nbeloglazov.com/2014/07/15/clojure-dojo-and-pubsub.html';

    (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>


    </div>
    <script src="/scripts/responsive.js" type="text/javascript"></script>
  </body>
</html>
