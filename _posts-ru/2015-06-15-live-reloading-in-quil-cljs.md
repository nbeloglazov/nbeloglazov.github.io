---
layout: post
title: Перезагрузка кода в Quil cljs
date: "2015-06-15 00:00:00"
---
Испокон веков Quil поддерживал перезагрузку кода на лету. Но только в кложур версии. В то время как поддержка таковой в кложурскрипт версии отсутствовала. Но эта проблема была устранена в последней версии (2.2.6). Так что теперь, при использовании плагинов для перезагрузки кода в кложурскрипт, например [figwheel](https://github.com/bhauman/lein-figwheel), Quil тоже будет вести себя прилично: при изменении функций (draw, update, обработчиков клавиш) - изменения будут отображаться мгновенно без необходимости обновлять страницу. Вот 3-шаговая инструкция как создать такой проект:

1 Создать новый cljs проект: `lein new quil-cljs hello` и перейти в папку `hello`.  
2 Настроить figwheel в `project.clj`:

  ```clojure
  ...
  :plugins [[lein-cljsbuild "1.0.6"]
              [lein-figwheel "0.3.3"]]
  ...
  :cljsbuild {:builds [{:source-paths ["src"]
                          :figwheel true
                          :compiler {...}}]}
  ```

3 Запустить figwheel: `lein figwheel`.

И всё. Теперь можно открыть `index.html` и вы должны увидеть вращающийся круг. Теперь измените `core.clj` и сохраните - все изменения должны (почти) мгновенно отобразиться в браузере. Например давайте изменим направление вращение круга - в функции `update` замените плюс на минус: `(- (:angle state) 0.1)` и сохраните файл. Круг должен начать вращаться против часовой стрелки.

Перезагрузка на лету работает только при использовании `defsketch`. Если использовать `sketch` - это не сработает (так же как и в кложур версии). При использовании `defsketch` все переданные функции (draw, update) оборачиваются в анонимные функции, так чтобы они вызывались по имени, а не по значению. Когда figwheel перезагружает `hello.core/draw` - Quil вызовет анонимную обёртку над draw, которая в свою очередь уже вызовет `hello.core/draw`. Без обёртки, Quil бы всегда использовал начальную версию draw и понятия не имел бы о том, значение в переменной `draw` на самом деле изменилось.
